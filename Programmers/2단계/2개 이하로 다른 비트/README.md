# [2개 이하로 다른 비트](https://programmers.co.kr/learn/courses/30/lessons/77885)

## 문제에 대한 생각

### __~~Exclusive OR 으로 변화된 Bits 를 구해서 Counting `O(N^2)`~~__

```bash
long n = a + 1
int count = 0
while count != (1 and 2); 
    count = 0
    long $e = Exclusive OR ( a , n )
    for char c in $e.toBinary().toCharArray()
        if c == '1' ? count++
    n++;
done

long result = n;

-----------------------------------

테스트 10 〉시간초과
테스트 11 〉시간초과
```

### __Exclusive OR 의 증감 활용 `O(logN)`__

```bash
long bit = ($0b11 or $0b1);
while (n ^ bit) < n
    bit '<<=' 1
done

long result = Math.min(bitA, bitB);

-----------------------------------

정확성  테스트
테스트 1 〉통과 (0.27ms, 52.5MB)
테스트 2 〉통과 (9.72ms, 78.1MB)
테스트 3 〉통과 (0.06ms, 51.7MB)
테스트 4 〉통과 (0.26ms, 53.3MB)
테스트 5 〉통과 (0.31ms, 53MB)
테스트 6 〉통과 (0.26ms, 52.5MB)
테스트 7 〉통과 (9.56ms, 95.9MB)
테스트 8 〉통과 (15.74ms, 108MB)
테스트 9 〉통과 (9.06ms, 91.9MB)
테스트 10 〉통과 (20.10ms, 101MB)
테스트 11 〉통과 (25.32ms, 98.6MB)
```

### __비트의 성질 이용 `O(N)`__

> - N보다 더 큰수 중 1개 혹은 2개의 비트가 다른 수
>   - N 이 `짝수`일 경우
>       - `1 더` 큰수 : `1의 자리` 비트 차이 ( __`1개의 비트변화`__ )
>   - N 이 `홀수`일 경우
>     - 더 큰수 중 `첫 반올림 비트만 변한 수` ( __`2개의 비트변화`__ )
>     - 예시
>       - 전 [ 0011 __0011__ 1111 ]
>       - 후 [ 0011 __0101__ 1111 ]

```bash

# 2의 보수와 Mask 비트의 위치 이동

음수 = 양수의 2의 보수 = 비트 반전 + 1 = ~A + 1

최하위 1비트 = A & (A의 2의 보수) = A & (-A)
최하위 0비트 = ~A & (~A의 2의 보수) = ~A & ~(~A) + 1 = -A & (A + 1)

$mask = 최하위 0 비트 = ~ number & (number + 1)
$mask 위치 이동
좌측 - $mask '<<' 1
우측 - $mask '>>' 1

최하위 0 비트 : 0 -> 1 = number | $mask
그 우측 비트  : 1 -> 0 - number & ~($mask >> 1)

짝수의 경우 1 의 자리로 $mask 를 만들고 (>> 1) 으로 결국 1 에서 0 이 되므로
홀수의 경우와 같이 사용할 수 잇다.

-----------------------------------

정확성  테스트
테스트 1 〉	통과 (0.07ms, 53.1MB)
테스트 2 〉	통과 (4.32ms, 77.4MB)
테스트 3 〉	통과 (0.03ms, 52.6MB)
테스트 4 〉	통과 (0.06ms, 53.1MB)
테스트 5 〉	통과 (0.11ms, 53.1MB)
테스트 6 〉	통과 (0.09ms, 52.6MB)
테스트 7 〉	통과 (4.45ms, 96.8MB)
테스트 8 〉	통과 (9.16ms, 106MB)
테스트 9 〉	통과 (4.18ms, 90.8MB)
테스트 10 〉	통과 (5.06ms, 101MB)
테스트 11 〉	통과 (4.40ms, 105MB)

```  

```bash

# 반올림 아래 비트의 1 연속성

$mask = 증감 중 변환된 비트 자리 구하기 : number ^ (number + 1)

반올림 전 비트는 전부 1 : 0111 -> 1000
반올림 변환된 비트자리  : 1111

$mask 반올림 자리수 2개를 제외 : 1111 >> 2 : 0011
변환된 $mask 를 이용하여 기존 자리수 복원
1. number + 1 | $mask
2. number + 1 + $mask

(number + 1) 의 $mask 위치는 0 이므로 덧셈이나 OR연산이나 무관하지만
OR 연산은 비교단계를 거치므로 단순연산인 덧셈이 더 간단하게 처리될 수 있다.

짝수의 경우 1 의 자리로 $mask 를 만들고 (>> 2) 으로 결국 1 에서 0 이 되므로
홀수의 경우와 같이 사용할 수 잇다.


-----------------------------------

정확성  테스트
테스트 1 〉	통과 (0.06ms, 52.7MB)
테스트 2 〉	통과 (3.35ms, 80.4MB)
테스트 3 〉	통과 (0.02ms, 51.9MB)
테스트 4 〉	통과 (0.04ms, 52.9MB)
테스트 5 〉	통과 (0.06ms, 52.2MB)
테스트 6 〉	통과 (0.05ms, 52.9MB)
테스트 7 〉	통과 (6.47ms, 98.7MB)
테스트 8 〉	통과 (3.25ms, 105MB)
테스트 9 〉	통과 (2.82ms, 80.8MB)
테스트 10 〉	통과 (3.17ms, 102MB)
테스트 11 〉	통과 (3.49ms, 104MB)

```
