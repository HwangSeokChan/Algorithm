# [다음 큰 숫자](https://programmers.co.kr/learn/courses/30/lessons/12911)

## 문제에 대한 생각

> - 조건
>   - 비트 1의 갯수가 같은 수
>   - 보다 큰수
>   - 조건을 만족하는 수중 가장 작은 수
> - 풀이
>   - __반목문을 통한 해결__
>     - 수의 증가
>     - 1의 수 확인
>   - __변화 기점에 따른 해결__
>     - 최하위 1 기준으로 좌측의 첫 `0` 을 기점으로 생각
>     - `0` 은 1로 변화
>     - `좌측`은 기존 유지
>     - `우측`은 기존 1의 갯수에서 기점에서 사용한 1을 제외한 횟수만큼 `LSB 부터 1로 변경` 소진 후에는 나머지는 `0`으로 대체
>   - __비트성격에 따른 해결__
>     - 비트 중 `1`의 갯수의 변화
>       - 감소 - 비트의 `반올림`
>       - 증가 - `0` 에서 `1`로 변경
>     - 수의 증가중 `비트 갯수 유지`에는 반올림이 필수
>       - `최하위 1` 에서 반올림한 이후부터 처음 `1의 갯수가 동일` 한 수가 정답
>     - 반올림 후 낮은 자리 수는 `기존 연속된 1의 갯수로 획득`
>       - 반올림 시 비트의 변화한 자리 중 `제일 높은 2자리`를 제외한 자리의 수는 `0으로 대체된 수`
>       - 이는 `변화한 자리가 표시된 비트`를 기존 `최하위 1`로 나누면 `0` 없이 우측부터 나열
>       - 이 중 반올림변화로 표시된 `최상위 2개의 비트를 제외`하면 `기존 1의 나열보다 1개 감소된 나열을 획득`
>     - 다음 큰 숫자 중 비트갯수가 동일한 수
>       - 반올림한 수(더 큰수) + 기존보다 하나 적은 비트나열(비트수를 동일하게 조정)  

## Pseudo code

### __Without Bit-Operator__ ( 변화 기점에 따른 해결 )
>
> - 반복문으로 `LSB부터 1의 최하위 비트` 의 위치를 찾는다.
> - 그 후 `연속된 1 의 갯수`를 기억한다.
> - `1` 이 아닌 `좌측 중 첫 0` 의 위치를 기억한 후 반복문을 종료한다.
> - `좌측 중 첫 0`을 `1`로 변경, `그보다 좌측은 기존 형태유지`
> - 그보다 우측은 `0`으로 대체
> - 단, 기억한 `연속된 1 의 갯수`의 갯수에서 `0`을 `변경한 1개를 제외`한 만큼 `LSB부터 1로 변경`

```bash
정확성  테스트
테스트 1 〉 통과 (0.06ms, 52.9MB)
테스트 2 〉 통과 (0.03ms, 52.7MB)
테스트 3 〉	통과 (0.04ms, 52.2MB)
테스트 4 〉	통과 (0.05ms, 52.1MB)
테스트 5 〉	통과 (0.06ms, 52.5MB)
테스트 6 〉	통과 (0.05ms, 53MB)
테스트 7 〉	통과 (0.05ms, 52.1MB)
테스트 8 〉	통과 (0.06ms, 52.3MB)
테스트 9 〉	통과 (0.06ms, 53.7MB)
테스트 10 〉	통과 (0.05ms, 53.2MB)
테스트 11 〉	통과 (0.05ms, 51.8MB)
테스트 12 〉	통과 (0.05ms, 52.2MB)
테스트 13 〉	통과 (0.05ms, 52.4MB)
테스트 14 〉	통과 (0.06ms, 53MB)
효율성  테스트
테스트 1 〉	통과 (0.05ms, 52.3MB)
테스트 2 〉	통과 (0.05ms, 51.8MB)
테스트 3 〉	통과 (0.06ms, 52.3MB)
테스트 4 〉	통과 (0.05ms, 54MB)
테스트 5 〉	통과 (0.05ms, 52.3MB)
테스트 6 〉	통과 (0.05ms, 51.7MB)
```

### __With Bit-Operator__

> - `2의 보수`를 사용하여, `최하위 1 비트 위치 ( MASK )` 를 찾는다.  
>   - `2의 보수`는 역전된 Bit 에 1을 더한 수로 `음수`를 표현한다.  
>   - `MASK` 는 `n & -n` 로 획득.
> - `반올림 기점의 앞자리 수`
>   - `Number` + `Mask` 를 `반올림 기점의 앞자리 수`를 획득
> - `반올림 기점의 뒷자리 수`
>   - 기존 `Number` 에서 변화된 비트의 갯수 (~~반올림이 수행된 자리~~) 는 `Exclusive OR` 연산을 통해 획득
>   - 이를 `Mask` 로 나누어 변화된 자리를 `1의 표시만으로 정제` 하여 가장 작은수로 변경
>   - 이 중 `반올림으로 카운트된 2개의 비트`를 `Shift 연산`으로 제외하면 `기존 1에서 0으로 변환된 비트`의 연속을 획득
>   - 이는 `반올림 기점의 뒷자리 수`이며, 기존 비트의 수를 맞춰준다.
>   - 또한 `Mask` 로 나누어 `0의 표시갯수`를 제외했기에 가장 작은 수로 표시된다.
>   - 즉, 이렇게 구한 반올림 기점의 `앞자리`와 `뒷자리`를 더하면 더 큰수 중 비트의 갯수가 가장 큰 작은 수가 된다.

```bash
정확성  테스트
테스트 1 〉	통과 (0.01ms, 54.3MB)
테스트 2 〉	통과 (0.01ms, 52.7MB)
테스트 3 〉	통과 (0.02ms, 52.4MB)
테스트 4 〉	통과 (0.02ms, 52.6MB)
테스트 5 〉	통과 (0.02ms, 51.8MB)
테스트 6 〉	통과 (0.02ms, 52.6MB)
테스트 7 〉	통과 (0.01ms, 52MB)
테스트 8 〉	통과 (0.01ms, 52.6MB)
테스트 9 〉	통과 (0.02ms, 53.1MB)
테스트 10 〉	통과 (0.02ms, 53.1MB)
테스트 11 〉	통과 (0.02ms, 52.9MB)
테스트 12 〉	통과 (0.02ms, 52MB)
테스트 13 〉	통과 (0.02ms, 52.2MB)
테스트 14 〉	통과 (0.02ms, 52.6MB)
효율성  테스트
테스트 1 〉	통과 (0.02ms, 52.3MB)
테스트 2 〉	통과 (0.03ms, 52.6MB)
테스트 3 〉	통과 (0.02ms, 51.9MB)
테스트 4 〉	통과 (0.02ms, 52.3MB)
테스트 5 〉	통과 (0.02ms, 52.1MB)
테스트 6 〉	통과 (0.01ms, 52.9MB)
```

### __Langs Fucntion__

> - 반복문 및 `언어에서 제공`되는 `비트 카운터`를 사용한다.

```bash
정확성  테스트
테스트 1 〉	통과 (0.02ms, 52.7MB)
테스트 2 〉	통과 (0.02ms, 51.8MB)
테스트 3 〉	통과 (0.02ms, 52.2MB)
테스트 4 〉	통과 (0.03ms, 52.2MB)
테스트 5 〉	통과 (0.03ms, 53.2MB)
테스트 6 〉	통과 (0.02ms, 52MB)
테스트 7 〉	통과 (0.02ms, 52.2MB)
테스트 8 〉	통과 (0.02ms, 52.4MB)
테스트 9 〉	통과 (0.03ms, 52.4MB)
테스트 10 〉	통과 (0.02ms, 52MB)
테스트 11 〉	통과 (0.01ms, 52.9MB)
테스트 12 〉	통과 (0.02ms, 52.2MB)
테스트 13 〉	통과 (0.02ms, 53.1MB)
테스트 14 〉	통과 (0.02ms, 52.1MB)
효율성  테스트
테스트 1 〉	통과 (0.01ms, 52.2MB)
테스트 2 〉	통과 (0.03ms, 53.1MB)
테스트 3 〉	통과 (0.02ms, 52.1MB)
테스트 4 〉	통과 (0.02ms, 52.8MB)
테스트 5 〉	통과 (0.03ms, 54.2MB)
테스트 6 〉	통과 (0.02ms, 52.4MB)
```
